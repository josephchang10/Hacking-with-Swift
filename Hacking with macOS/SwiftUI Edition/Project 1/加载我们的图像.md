在你设置这个项目时，你应该已经把我提供给你的这些图像资源拷贝进了你的资源目录中。那么，现在是时候把它们投入使用了，在我们的列表内部显示它们。

你已经见过如何使用一个范围来创建 **List**，而由于我们的图像是从 1 到 10 编号的，我们正好可以使用那种方法来显示它们全部。

把你当前的 **List** 代码替换成这个：

```swift
List(0..<10) { number in
  Text("Storm \(number + 1)")
}
```

那会显示 10 行，我们添加的每个风暴（storm）文件一行。如果你运行这个 app 你会看到它们全部，但你也会发现你实际上无法选择任何行——这是因为我们都还没有告诉 SwiftUI 是可以选择的。

SwiftUI 开发者者有一种说法，即我们的“视图是它们状态的一个函数”，虽然这只有几个词语，但它刚开始对你来说可能不知所云。

如果你在玩一个格斗游戏，你可能失去了几条生命、得到了一些分数、收集了一些宝藏，还可能捡到了一些强力武器。在编程中，我们把这些东西称为*状态（state）*——当前的设定集合，描述了游戏目前如何。

当我们说 SwiftUI 的视图是它们状态的一个函数时，我们指的是你的用户界面的外观——人们可以看到的东西，也是他们可以与之交互的——是由你的程序的状态决定的。例如，他们无法点击 Continue，除非他们已经在一个文本框（text field）中输入了他们的名字。

由于在你的用户界面中显示什么直接受到程序状态的影响，SwiftUI 需要确切知道你正在处理的状态是什么，以便它可以监控变化并按需更新东西。这都是使用一个*属性包装器（property wrapper）* 完成的，它是一段附加的代码，在你的任何一个属性边以添加额外的功能——在这个例子中，它的功能是允许 SwiftUI 监控变化并在视图变化时更新你的视图。

在这个程序中，我们需要一些状态以记录当前选中的是哪一行，那么现在添加这个：

```swift
@State private var selectedImage: Int?
```

这一次同时做了几件事情，所以我们把它拆开：

1. 这个 **@State** 属性包装器标记了一块程序状态，我们希望在程序运行时改变它。
2. 这个特定属性包装器被用于*局部（local）* 状态——只有这个视图使用的状态——因此我们把它标记为 **private** 了，以强调这一点。
3. 这个属性叫做 **selectedImage（选中的图像）**，这很好理解因为它会记录被选中的图像编号。
4. 它是一个整型，因为它会追踪图像编号。
5. 那个整型是*可选的*，因为用户可能点击空白并因此取消了选中的图像。
6. 这个整数没有默认值，表示默认不会选中任何图像。

然而，只是添加这个新属性不足以把它附加到我们的 **List** 上。为了这个我们需要另一项重要的 SwiftUI 功能：双向绑定（two-way bindings）。

双向绑定允许信息双向流动：从我们的属性到用户界面，或者从用户界面回到这个属性。在我们的列表这个例子中，那意味着使用类似这样的 **selectedImage = 5** 修改我们的属性会导致被 UI 中被选中的行也改变，而且在 UI 中点击另一行也会导致这个属性的值被更新。

SwiftUI 中的双向绑定是被它们属性名之前的美元符号标记的，那么让我们继续并把我们的列表的选中与这个 **selectedImage** 属性绑定——把你的 **List** 代码改成这样：

```swift
List(0..<10, selection: $selectedImage) { number in
```

如果你现在运行这个 app 会看到进展，因为你现在可以选择任意行以使其高亮，或者点击列表上的某处空白以取消所有选择。

![Pasted image 20240129103816.png](./attachments/Pasted%20image%2020240129103816.png)