不管你信不信吧，这个项目快完成了！最后一步是对用户在列表中选择一张图片做出响应并在我们的拆分视图的右手边显示这张相关图像。

要让这个起作用就需要认识另一个 SwiftUI 视图，以及两个新的修饰符。然而，在这个过程中你会更好地了解 SwiftUI 是如何响应状态变化的，以及为什么它会让我们的生活简单的多。

目前我们的拆分视图的右手边只是写着“Right（右）”，但实际上那需要写一些更有意义的东西——那个文字会在 app 首次运行时显示，在用户选择任何一张图像之前，因此一点儿提示是很有帮助的。

把它改成这样：

```swift
Text("Please select an image")
  .frame(maxWidth: .infinity, maxHeight: .infinity)
```

现在是重要的部分：当用户*确实*选了一张图像时，我们需要把那段文本替换为他们实际选择的图像。这可以通过 SwiftUI 的 **Image** 视图完成，但真正的问题是我们怎么知道要显示哪个——图像还是文本。

那么，由于我们的 **selectedImage** 属性是一个可选的整型，因此这里的答案很简单：如果我们可以从哪个属性读取一个值则我们能够显示这张图像，否则我们应该显示文本。这可以通过 **if let** 安全地解开可选型来完成，因此把这个放到你目前的 **Text** 提示周围：

```swift
if let selectedImage = selectedImage {
  Image(String(selectedImage))
} else {
  // "Please select an image" 文本
}
```

我们的 **selectedImage** 属性是一个整数，但 SwiftUI 的 **Image** 视图想要一个资源*名称*来加载，因此我们需要把那个整数转化为一个字符串。当那段代码运行时 SwiftUI 会自动在资源目录中寻找一个与我们选择的数字相匹配的文件——它会忽略任何文件扩展名，也就是说加载 1 会加载我们的 1.png 图片。

如果你现在运行这个 app 你会发现发生了一些相当令人惊讶的事情：当你选择一张图片时，你的窗口的大小会跳成相当不同的尺寸，而且这个拆分视图左侧的列表有可能会整个消失。

![Pasted image 20240130111412.png](./attachments/Pasted%20image%2020240130111412.png)
发生这种情况的的原因与我们原始的“Hello, world!”窗口非常小的原因相同：SwiftUI 会自动调整它的用户界面以适配其内容的大小。在这个例子中我们的 **List** 默认拥有灵活的宽度和高度，但是新显示的这个 **Image** 有一个固定的大小，即图像文件的实际尺寸。因此，当 SwiftUI 需要显示该图像时，它会首先缩小给这个 **List** 分配的空间，以便它可以显示更多图像，但当它把这里的空间用光时它会直接扩大窗口。

这个结果不是很好：让列表消失是一次相当令人不快的用户体验，而之后强制让窗口变到更大的尺寸也很差。

为了修复这一点我们需要给我们的视图添加一些额外的修饰符，从这个 **List** 开始。如我所说，它默认拥有灵活的宽度和高度，但我们可以覆盖那一点以设置一个最小宽度，或者如果我们想，甚至是一个精确的宽度。

在这个例子中我觉得精确的宽度效果最好，因为我们知道需要多少空间。因此，给这个列表添加一个 **frame()** 修饰符，像这样：

```swift
List(0..<10, selection: $selectedImage) { number in
  Text("Storm \(number + 1)")
}
.frame(width: 150)
```

现在，在显示不同的图像时这个窗口的大小还是会跳来跳去——例如，最后一张图像尤其的宽——但至少这个列表现在不会消失了。

![Pasted image 20240130113627.png](./attachments/Pasted%20image%2020240130113627.png)
下面我们要让这张图像尺寸可变（resizable），以使它尽可能多地填充当前窗口内的可用空间，而不是强制所有都重新调整大小。这可以通过给图像使用 **resizable()** 修饰符来完成，像这样：

```swift
Image(String(selectedImage))
  .resizable()
```

![Pasted image 20240130115601.png](./attachments/Pasted%20image%2020240130115601.png)
这修复了这个窗口改变大小的问题，但如果你仔细看你会发现它引入了一个新问题：这些图像现在被压扁了！这个 **resizable()** 修饰符告诉 SwiftUI，我们的图像拥有灵活的宽和高，允许它在我们的 UI 中占据所有可用空间。然而，那也代表它会拉伸以匹配那个空间，哪怕这意味着改变该图像的长宽比（aspect ratio）——例如，它现在可以是非常细长的，尽管原始图像不是那个形状。

为了解决这一点我们需要*另一个*修饰符。记得我说过，“给单一视图堆叠多个修饰符是常见的”吗？那么，这里是一个关于那一点的很好的例子——我们直接把这些修饰符叠起来以精确创建我们想要的效果。

在这个例子中这个修饰符被称为 **scaledToFit()**，表示风暴图像在被改变尺寸时会保持它原始的长宽比。实际上，这意味着大部分时间在图像上下或左右会有一些空白，取决于可用的空间。

把你的图像代码改成这样：

```swift
Image(String(selectedImage))
  .resizable()
  .scaledToFit()
```

按 Cmd+R 以再次运行这个 app，你应该会发现它的表现好多了——那很简单吧，我感觉！

![Pasted image 20240130122336.png](./attachments/Pasted%20image%2020240130122336.png)