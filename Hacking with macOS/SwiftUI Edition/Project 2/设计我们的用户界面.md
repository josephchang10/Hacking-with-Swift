猜数字需要三个 UI 组件：一个给用户输入他们的猜测的文本字段、一个提交他们的答案的“Go”按钮，以及一个包含他们之前猜测的大列表。

每次用户新增一个猜测时，我们会把它添加到列表中。这意味着我们希望用户界面能够纵向调整大小，这样玩家如果愿意的话可以看到更多答案，但我们希望它有一个固定的横向大小。

首先来说：我们要把所有 UI 摆放在屏幕上，连接到示例数据上，以便我们可以看到它们的外观。

如果你想返回不止一个视图，你需要告诉 SwiftUI 它们应该被如何排列。在这个 app 中我们让一个文本字段和一个按钮并排，然后那下面是一个包含他们之前全部猜测的大列表，以及他们是对还是错。用 SwiftUI 术语来说，这表示同时使用一个水平堆栈（stack）（并排摆放东西）以及一个垂直堆栈（上下摆放东西）以制作一个类似网格的结构。

后面我们还会看到很多很多网格，但目前让我们从简单的开始——把你当前的 **body** 属性替换为这个：

```swift
var body: some View {
  VStack {
    HStack {
      TextField("Enter a guess...", text: .constant("1234"))
      Button("Go", action: submitGuess)
    }
  }
}
```

我们马上会回来讨论这个做了什么，但首先你需要给 **ContentView** 添加一个 **submitGuess()** 方法以便让你的代码能够编译：

```swift
func submitGuess() {

}
```

继续，现在运行你的项目，你会看到一个包含了我们的文本字段和按钮的窗口——你应该能够通过抓住任意边缘来自由地调整它的大小，但这个文本和按钮会一直居中。

![Pasted image 20240131131150.png](./attachments/Pasted%20image%2020240131131150.png)
在我们继续并调整那个设计之前，让我们停下并检查我们已经写下的几行代码。首先，我们的两个堆栈：

```swift
VStack {
  HStack {
    // 这里是更多代码
  }
}
```

这创建了一个垂直堆栈，里面有一个水平堆栈。每个堆栈可以包含最多 10 个视图，并且会并排放置它们——对于 **VStack** 是垂直的而对于 **HStack** 则是水平的。对于更高级的布局，你可以混合并搭配 **HStack** 和 **VStack** 以创建网格。

**提示：** 还有第三种堆栈类型，叫作 **ZStack**，允许我们把视图放在其他的上面以创建深度，但我们这里不需要它。

在我们的水平堆栈内部我们添加了这个视图以创建一个用户可以在其中输入的文本框：

```swift
TextField("Enter a guess...", text: .constant("1234"))
```

如你所见，这接受两个参数：一个显示为占位符的字符串，以便用户获得他们应该输入什么的提示，以及实际放在内部的文本。对于这个文本我们指定的是一个常量值“1234”，这意味着在 app 启动时会在该文本字段中提前填上它。

在这个文本字段后我们创建了一个按钮：

```swift
Button("Go", action: submitGuess)
```

macOS 给了我们一些按钮样式，但如果我们不做任何具体的请求我们会得到一个默认的“下压按钮（push button）”风格——它有一个轻微的 3D 效果、一个灰色的背景以及在按下时的颜色。当这个按钮被点击时它会调用我们的 **submitGuess()** 方法，它当前不做任何事情。

在给我们的 UI 添加一份猜测列表前，首先让我们的窗口占据更多空间。从给 **HStack** 添加这个修饰符开始，以在我们的布局周围添加一点儿空间：

```swift
.padding()
```

你的代码应该看起来像这样：

```swift
HStack {
  TextField("Enter a guess...", text: .constant("1234"))
  Button("Go", action: submitGuess)
}
.padding()
```

默认，这个 **padding()** 修饰符会给每一边都增加一些间距——具体数量要看 SwiftUI 认为多少合适，而它通常都能做得很好。如果你判断这个默认间距不是很合适，你可以传一个数字给 padding，例如 **padding(40)**，以获得一个精确数量的间距。

如果你再次运行这个 app，你会发现这个文本字段和按钮不再紧靠着它们窗口的边缘，看起来更好了。

现在给这个 **VStack** 添加这两个修饰符：

```swift
.frame(width: 250)
.frame(minHeight: 300)
```

是的，这里是两次相同的 **frame()** 修饰符，这凸显了一个 SwiftUI 的有趣功能：你可以多次应用同一修饰符，而它们会直接组合。在这个例子中我们告诉 **VStack** 它有一个精确的宽度 250，这意味着它不能比这更宽或是更窄。我们然后给它添加了一个最小高度 300，意味着这个 **VStack** 必须至少有那个高度，也可以更高。

现在，仅仅告诉这个 **VStack** 它有一个固定的大小不足以强制让整个*窗口（window）* 成为那个尺寸。为了达到这个效果，我们需要在 CowsAndBulls.swift 内部添加一个新的 **windowResizability()** 修饰符——这会告诉 SwiftUI 这个窗口的尺寸应该仅基于其内容计算，而不是试图自由调整大小。

因此，给 **WindowGroup** 添加这个修饰符：

```swift
.windowResizability(.contentSize)
```

如果你再次运行这个 app 你会发现两件事：

1. 这个窗口大多了，这说得通因为是我们要求它这样的。
2. 你完全不能调整这个窗口的大小了，这大概是个意外——我们没有指定一个固定的高度！

那么，如果我们在使用 **frame(minHeight:)** 时会获得一个固定的高度，何苦使用它呢——何不直接指定固定的高度？

在这里发生的情况是这样的，SwiftUI 看了我们的视图内容，并尽可能让窗口适配我们拥有的内容。我们说的有一个最小高度意味着 SwiftUI 将始终确保至少有那么多空间可用，但没有指定一个*最大*高度，SwiftUI 会恢复到它之前的行为，让窗口紧紧包裹其内容。

现在，我们可以通过声明最大高度是多少都行来修复这一点，像这样:

```swift
.frame(minHeight: 300, maxHeight: .infinity)
```

然而，在这个项目中没有这个必要，因为我们会直接在那个 **VStack** 下面添加一个列表，显示一个由这位玩家做出的所有猜测组成的列表。还记得吧，SwiftUI 的列表本身的边框（frame）是灵活的，因为它们被设计为可滚动（scroll）的，所以只要我们添加了一个，无论怎样 SwiftUI 都会让高度是灵活的。

让我们现在添加这个猜测列表。首先，我们需要一些示例数据以在该列表中显示，因此把这个作为属性添加给 **ContentView**：

```swift
let guesses = Array(repeating: "1234", count: 20)
```

这会创建一个有 20 个字符串的数组，每个都是“1234”——我们不会在最终的项目中使用这个，但它足以让我们制作这里的原型。

现在这个放在 **body** 属性的 **padding()** 修饰符后面：

```swift
List(guesses, id: \.self) { guess in
  HStack {
    Text(guess)
    Spacer()
    Text("4c 0b")
  }
}
```

就像上次一样，在我解释这些代码在做什么之前，我希望你能运行这个项目。你现在应该能在文本字段和按钮下面看到一个有项目的滚动表格，在这个表格中的每一行都包含“1234”和一个空格和“4c 0b”——“4 cows 0 bulls”的简写，表示四个猜测的数字全都在答案中的某处（奶牛），但没有一个处在正在的位置上（公牛）。

OK，让我们拆解这些代码，从这个开始：

```swift
List(guesses, id: \.self) { guess in
  // 这里是更多代码
}
```

这使用我们的 **guesses** 数组创建了一个新的列表，它会为数字中的每个元素自动在该列表中创建一行。我们之前看过 **\.self**，这告诉 SwiftUI，它仅通过查看文本本身即可识别我们的 **guesses** 数字中的每个项目——我们在表达这个数组中的每个字符串都将是唯一的。

坦白说：这是个谎言。我们的 **guesses** 数组并*没有*包含唯一的数据，因为我们让这个字符串“1234”重复了 20 次，而如果看一下你的 Xcode 窗口的右下方，你会发现我们已经被揭穿了——有一个大大的警告消息，说“ID 1234 occurs multiple times within the collection, this will give undefined results!（ID 1234 在这个集合内多次出现，这将导致不确定的结果！）”

理解这里发生了什么以及为什么存在这个问题是至关重要的，因此我想暂停片刻，在这里深入一下。

当我们从一个数组制作一个列表时，SwiftUI 会自动观察该数组，以便在添加或移除项目时也会自动从这个列表中被插入或移除它们。

想象我们有一个像这样的数组：

```
Hello
World
```

如果我们插入一个项目，可能会得到这个：

```
Hello
SwiftUI
World
```

对我们来说改变了什么是显而易见的，因为我们会发现这第一个和最后一个项目是相同的，并在中间插入了一个项目。Swift 自己也可以看出这一点，因为它内置了检测差异的功能。因此，SwiftUI 依靠这个来更新它的列表：它会动画出一些空间，然后插入新的一行，内有”SwiftUI“。

在给定一个数据数组时，SwiftUI 想知道它怎样可以唯一识别这个数组中的每个项目，以便它可以在东西改变时插入和移除行。在字符串数组这个情况下，我们唯一可用的就是这个字符串本身，因此当我们写 **id: \.self** 时我们就是在说”你可以使用项目本身来唯一识别这个数组中的每个项目“。

这通常很有效，但也确实带来了一个重要的隐忧，你在假设你的所有项目都会是唯一的。例如，想象我们从这个：

```
Hello
SwiftUI
```

变成这个：

```
Hello
SwiftUI
SwiftUI
```

我们可以从视觉上看出这个列表已经改变了，然而我们不知道它是*如何*改变的——我们是加了一个新的”SwiftUI“到最后，还是它被插到中间了？SwiftUI 无法判断这是如何改变的，所以尽管它会更新列表以反应该变化，但你很有可能会得到错误的动画。

在我们的设计中我们把”1234“重复了 20 次，正是它导致 SwiftUI 在 Xcode 中打印了警告，但没关系——这只是暂时的，在我们让真正的游戏开始前。

最后一段代码是给这些列表行本身的：

```Swift
HStack {
  Text(guess)
  Spacer()
  Text("4c 0b")
}
```

这个 **Text** 视图是一个简单的标签，但 **Spacer** 是新的：它的作用是占据所有可用空间，在这种情况下就意味着我们的两个文本视图中间会有一片巨大的空白。你想添加多少个 spacer 视图都可以，它们之间会平分空间。

好，这些代码全都解释过了，不过在完成我们的设计前我想再添加一样东西。你有发现我们的文本字段和按钮上面、左面和右面的空间是相等的，但下面的空间略大一些吗？

![Pasted image 20240131174401.png](./attachments/Pasted%20image%2020240131174401.png)
SwiftUI 这是在试图提供帮助：当你把两个视图放进 **VStack**时，它会在它们之间添加一点点间隔以避免它们紧紧贴在一起。

我们的设计已经给这个 **HStack** 增加了一些间距，因此我们不希望 SwiftUI 自己给 **VStack** 添加间距。所以，把这个 **VStack** 的代码改成这样：

```Swift
VStack(spacing: 0) {
```

那 SwiftUI 的自动间距就被禁用了，而且看起来好多了。

![Pasted image 20240131175030.png](./attachments/Pasted%20image%2020240131175030.png)
