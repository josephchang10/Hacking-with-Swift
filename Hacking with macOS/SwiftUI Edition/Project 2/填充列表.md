这个项目中的下一步是允许用户向文本字段中输入值，并在他们点击“Go”时把这些添加到答案列表。答案列表中的每一行都需要显示用户猜的什么（例如“1234”）以及把它和隐藏答案对比的结果（例如“2c 1b”）。

为了让我们的代码更容易阅读（和编写！），这个结果运算会在一个单独的方法中完成。我们会在后面填充它，但目前请先把这个占位方法添加到 **ContentView**：

```swift
func result(for guess: String) -> String {
  "Result"
}
```

我们可以让这个生效，通过把硬编码的“0c 4b”字符串替换成这个：

```Swift
List(guesses, id: \.self) { guess in
  Text(guess)
  Spacer()
  Text(result(for: guess))
}
```

这现在使用了 **result()** 方法以搞清楚每次猜测有多接近——它仅仅会让每个显示“Result”，但我们很快就会解决它。

这个项目中的下一步是创建一个随机的四位数字给玩家来猜。它不应该有重复的数字，而且每次都要不同。我们会让这成为一个新的方法，叫作 **startNewGame()**，以便我们可以再次调用它以重置游戏好再玩一次。

在我向你展示代码前，让我们走一遍这个 **startNewGame()** 方法需要做的事情：

1. 它需要清空文本字段，无论用户在那里输入了什么。在 app 首次运行时这应该是空的，但如果我们开始了另一局游戏，它会存在一个值。
2. 它需要清除 **guesses** 数组中所有之前的猜测。还记得吧，SwiftUI 会观察其变化，并同时自动清除列表。
3. 它会创建一个包含数字 0 到 9 的范围，然后打乱它以使其顺序随机。
4. 然后它会把这个数组的前四个项目附加到 **answer** 字符串上。

这大部分需要新的功能，因此让我们把它进一步拆解。

首先， 给 **startNewGame()** 添加这个方法存根，以便有地方来写我们的代码：

```Swift
func startNewGame() {
}
```

目前我们是这样指定文本字段中的文本的：

```Swift
TextField("Enter a guess...", text: .constant("1234"))
```

这会强制那里的值是 1234，但实际上我们希望允许用户输入任何它们想要的东西并把那个值存在某个地方。这表示该值会随时间改变：它开始可能是 1234，然后用户会在玩游戏时不断改变它。

这是*状态*的又一个例子，表示我们需要使用 **@State** 属性包装器，这样 SwiftUI 会允许我们把一个属性的值绑定到我们的用户界面，并在这个值改变时自动更新 UI。

让我们把这一切付诸实践：我们知道文本字段应该存储一个字符串，而那个字符串会随时间改变，因为用户会在这个文本字段中输入一些新东西。因此，我们可以使用 **@State** 来给 **ContentView** 添加一个属性，它会存储这个文本字段的字符串。

把这个属性添加到 **ContentView**：

```Swift
@State var guess = ""
```

现在与其用 **.constant("1234")** 指定文本字段的内容，不如使用那个 **guess** 字符串代替，像这样：

```Swift
TextField("Enter a guess...", text: $guess)
```

注意到那里的美元符号了吗？没错，**TextField** 采用了另一个双向绑定——我们可以通过调整 **guess** 把文本放进那里，但如果用户向文本字段中输入了内容那么 **guess** 也会被更新。

现在，既然我们的猜测字符串是我们可以随时改变的状态，在我们开始一次新游戏时清空那个字符串就变得简单了。给 **startNewGame()** 添加这第一行代码：

```Swift
guess = ""
```

这使用了 **guess** 而非 **$guess**，这是有意的：当你说 **guess** 时是指“读取或写入这个 **guess** 字符串”，但当我们说 **\$guess** 时是指“同时读取*和*写入这个 **guess** 字符串”——这个美元符号指代双向绑定，确保如果该属性改变了那么这个文本字段也会被更新，而如果这个文本字段改变了那么该属性也会被更新。

这不是我们在这个游戏中唯一需要的状态，因为随着游戏的进行至少有两项其他数据也会变化：他们尝试猜测的答案在我们每次开始一场新游戏时都会改变，以及他们当前猜测的列表也会随着他们添加增加猜测而改变。

目前我们的 **guesses** 数组通过固定数据被创建为一个常量，但那在我们的游戏中显然行不通，因为我们想记录用户的实际猜测。相反，这需要成为一个变量数组，而且也使用 **@State** 属性包装器以便它可以随时间变化。

把目前的 **guesses** 数字替换成这个：

```Swift
@State var guesses = [String]()
```

有了这个改变，我们可以返回去写 **startNewGame()** 了，因为我们可以现在写代码当一局新游戏开始时移除这个猜测数组中的所有项目。在之前的代码下面添加这个：

```swift
guesses.removeAll()
```

这个 **removeAll()** 方法可以接受一个叫作 **keepingCapacity** 的参数——如果那为真，这个数组会移除它的项目，但仍然有空间去添加同样多的项目。如果你真的遇到瓶颈，这会是一次小幅的性能优化，但这里我们可以忽略它。

下一步是创建第三个 **@State** 属性以存储玩家尝试猜测的答案，但我也会在这里存储该答案的长度以避免在我们的代码中到处重复数字 4：

```Swift
@State var answer = ""
let answerLength = 4
```

现在我们可以为玩家生成一个答案来猜测，作为 **startNewGame()** 的一部分。还记得吧，他们尝试猜测的答案是由数字 0 到 9 组成的四字的字符串，不会有数字重复。我们可以如此获得它：

1. 创建一个包含数字 0 到 9 的范围。
2. 打乱它
3. 挑出前四个值。

要创建一个数字数组，我们可以使用 Swift 的闭区间运算符，**…**，带上 0 和 9。那会生成一个从 0 到 9 的区间，然后我们可以把它打乱（shuffle）成随机的顺序：

```Swift
answer = ""
let numbers = (0...9).shuffled()
```

那会清除 **answer** 中已经存在的所有东西，然后创建一个以随机顺序包含 **[0, 1, 2, ... 8, 9]** 的新数组。

最后一步是从被我们随机打乱的数组中取出前四个数字，意味着我们可以保证没有数字会出现两次。每个数字都是这个数组中的一个整数，因此我们需要把它从该数组中取出并将其转换为一个字符串，像这样：

```Swift
for i in 0..<answerLength {
  answer.append(String(numbers[i]))
}
```

这就是你需要知道的全部了——这是给 **startNewGame()** 的完整代码：

```Swift
func startNewGame() {
  guess = ""
  guesses.removeAll()
  answer = ""

  let numbers = (0...9).shuffled()

  for i in 0..<answerLength {
    answer.append(String(numbers[i]))
  }
}
```

这个方法应该在 **ContentView** 显示时被触发，而那意味着使用在项目 1 中遇到的同一个 **onAppear()** 修饰符。

因此，把这个放到 **VStack** 那两个 **frame()** 修饰符下方：

```Swift
.onAppear(perform: startNewGame)
```

如果你现在运行代码，你会发现它看起来像是我们倒退了一大步，因为现在我们的列表完全是空的。但是，我们才刚铺垫好实现这个游戏的基础工作，而如果我们在 **submitGuess()** 中插入几行代码，你就能亲眼看到了。

现在，试试这个：

```Swift
func submitGuess() {
  guesses.append(guess)
  guess = ""
}
```

![Pasted image 20240131203332.png](./attachments/Pasted%20image%2020240131203332.png)
这不是我们的游戏的最终代码，但足以让你实际尝试我们做出的东西——你可以在这个文本字段中输入任何东西，而当你按下 Go 时它会滑入下方的列表。因为那个 **@State** 属性包装器这一切才得以实现：它告诉 SwiftUI 去观察 **guesses** 数组的变化，以便它可以在项目被添加时保持列表同步。

这幕后实际发生的是，每次那个 **@State** 的值改变时它会重新调用我们的视图的 **body** 属性，这种花里胡哨的说法是指它会带上最新的属性值，再次运行它的所有代码。这意味着我们的视图总是能够为它所有的 **@State** 属性保持最新状态，因为每当其中一个改变时，这整个视图都会被更新。

在我们结束之前我想提醒你，无论你何时使用 **@State** 属性包装器，使用 private 访问控制基本都是一个好主意——它提示了这块程序状态是由当前视图所拥有的。这不是必需的，但是建议的。因此，把你的三个属性改成这样：

```Swift
@State private var answer = ""
@State private var guess = ""
@State private var guesses = [String]()
```

